# Otto机器人行走机制详细分析

## 📋 基本信息

**分析时间**: 2025-10-29  
**步态类型**: 静态摆动步态（Static Waddle Gait）  
**核心原理**: 重心转移 + 双脚同步滑动

---

## 🤖 机械结构回顾

### 舵机配置

```
舵机编号:
  0 - LEFT_LEG   (左腿)  - 绕Z轴（竖直）旋转
  1 - RIGHT_LEG  (右腿)  - 绕Z轴（竖直）旋转
  2 - LEFT_FOOT  (左脚)  - 绕Y轴（水平）旋转
  3 - RIGHT_FOOT (右脚)  - 绕Y轴（水平）旋转
  4 - LEFT_HAND  (左手)  - 可选
  5 - RIGHT_HAND (右手)  - 可选
```

### 运动轴向

```
坐标系（机器人站立状态）:
  X轴: 前 → 后
  Y轴: 左 → 右
  Z轴: 下 → 上

LEFT_LEG & RIGHT_LEG:
  转轴: Z轴（竖直）
  作用: 左右摆动，控制重心转移
  
LEFT_FOOT & RIGHT_FOOT:
  转轴: Y轴（水平，从左到右）
  作用: 前后摆动，控制迈步
```

---

## 🚶 Walk函数核心参数

### 当前配置

```cpp
void Otto::Walk(float steps, int period, int dir, int amount) {
    // 振幅 - 每个舵机的摆动幅度（±度数）
    int A[SERVO_COUNT] = {
        30,  // LEFT_LEG:  左右摆动±30°
        30,  // RIGHT_LEG: 左右摆动±30°
        30,  // LEFT_FOOT: 前后摆动±30°
        30,  // RIGHT_FOOT:前后摆动±30°
        0, 0 // 手部默认不动
    };
    
    // 偏移 - 每个舵机的中心位置（基准角度）
    int O[SERVO_COUNT] = {
        0,   // LEFT_LEG:  0° (垂直站立)
        0,   // RIGHT_LEG: 0° (垂直站立)
        5,   // LEFT_FOOT: +5° (略微踮脚)
        -5,  // RIGHT_FOOT:-5° (略微踮脚)
        HAND_HOME_POSITION - 90,
        HAND_HOME_POSITION
    };
    
    // 相位差 - 控制各舵机的运动时序
    double phase_diff[SERVO_COUNT] = {
        0,                    // LEFT_LEG:  基准相位（0°）
        0,                    // RIGHT_LEG: 同相（0°）
        DEG2RAD(dir * -90),   // LEFT_FOOT: -90°相位差（前进时）
        DEG2RAD(dir * -90),   // RIGHT_FOOT:-90°相位差（前进时）
        0, 0
    };
}
```

---

## 🔬 运动学分析

### 正弦波运动公式

每个舵机的位置由以下公式计算：

```cpp
position = A * sin(phase + phase0) + O + 90

其中：
  A = 振幅（amplitude）
  phase = 当前相位（随时间递增）
  phase0 = 初始相位差（phase_diff）
  O = 偏移量（offset）
  90 = 舵机中立位置
```

### 相位随时间变化

```cpp
// 在Oscillator构造函数中
number_samples_ = period / sampling_period_;  // 2000ms / 20ms = 100个采样点
inc_ = 2π / number_samples_;                  // 每次增加 2π/100 = 0.0628弧度

// 在Refresh()中每次调用
phase_ = phase_ + inc_;  // 相位递增
```

**含义**: 
- 一个完整周期（period）会让phase从0增加到2π
- 完成一个完整的正弦波周期

---

## 📊 前进步态详细分解

### 参数配置（前进时，dir=1）

```
LEFT_LEG:   A=30°, O=0°,  phase=0°
RIGHT_LEG:  A=30°, O=0°,  phase=0°      (与左腿同相)
LEFT_FOOT:  A=30°, O=+5°, phase=-90°    (滞后90°)
RIGHT_FOOT: A=30°, O=-5°, phase=-90°    (滞后90°)
```

### 一个完整步态周期（2000ms，分8个关键点）

#### 时刻1: phase = 0° (0ms)

```
腿部运动:
  LEFT_LEG:  30*sin(0°+0°) + 0 + 90 = 0 + 90 = 90°   (中立位置)
  RIGHT_LEG: 30*sin(0°+0°) + 0 + 90 = 0 + 90 = 90°   (中立位置)
  
  → 重心居中

足部运动:
  LEFT_FOOT:  30*sin(0°-90°) + 5 + 90 = -30 + 95 = 65°  (向后，踮脚)
  RIGHT_FOOT: 30*sin(0°-90°) - 5 + 90 = -30 + 85 = 55°  (向后，踮脚)
  
  → 双脚都向后倾斜（准备向前迈）

机器人状态:
  重心: 中间
  双脚: 向后倾斜
  效果: 准备开始步态
```

#### 时刻2: phase = 45° (250ms)

```
腿部运动:
  LEFT_LEG:  30*sin(45°) + 90 ≈ 21 + 90 = 111°
  RIGHT_LEG: 30*sin(45°) + 90 ≈ 21 + 90 = 111°
  
  → 双腿开始向左摆动，重心向左转移

足部运动:
  LEFT_FOOT:  30*sin(45°-90°) + 5 + 90 ≈ 30*sin(-45°) + 95 ≈ -21 + 95 = 74°
  RIGHT_FOOT: 30*sin(-45°) - 5 + 90 ≈ -21 + 85 = 64°
  
  → 双脚仍向后，但开始向中心移动
```

#### 时刻3: phase = 90° (500ms) ⭐重要

```
腿部运动:
  LEFT_LEG:  30*sin(90°) + 90 = 30 + 90 = 120°
  RIGHT_LEG: 30*sin(90°) + 90 = 30 + 90 = 120°
  
  → 双腿摆到最左侧，重心完全在左边

足部运动:
  LEFT_FOOT:  30*sin(90°-90°) + 5 + 90 = 30*sin(0°) + 95 = 0 + 95 = 95°
  RIGHT_FOOT: 30*sin(0°) - 5 + 90 = 0 + 85 = 85°
  
  → 双脚回到中立位置（略微踮脚）

机器人状态:
  重心: 完全在左边
  双脚: 中立位置（地面摩擦力最小）
  效果: 这是双脚最容易滑动的时机！
```

#### 时刻4: phase = 135° (750ms)

```
腿部运动:
  LEFT_LEG:  30*sin(135°) + 90 ≈ 21 + 90 = 111°
  RIGHT_LEG: 30*sin(135°) + 90 ≈ 21 + 90 = 111°
  
  → 双腿开始从左向中间摆动

足部运动:
  LEFT_FOOT:  30*sin(135°-90°) + 5 + 90 = 30*sin(45°) + 95 ≈ 21 + 95 = 116°
  RIGHT_FOOT: 30*sin(45°) - 5 + 90 ≈ 21 + 85 = 106°
  
  → 双脚开始向前倾斜
```

#### 时刻5: phase = 180° (1000ms) ⭐重要

```
腿部运动:
  LEFT_LEG:  30*sin(180°) + 90 = 0 + 90 = 90°
  RIGHT_LEG: 30*sin(180°) + 90 = 0 + 90 = 90°
  
  → 重心回到中间

足部运动:
  LEFT_FOOT:  30*sin(180°-90°) + 5 + 90 = 30*sin(90°) + 95 = 30 + 95 = 125°
  RIGHT_FOOT: 30*sin(90°) - 5 + 90 = 30 + 85 = 115°
  
  → 双脚向前倾斜到最大

机器人状态:
  重心: 中间
  双脚: 向前倾斜最大
  效果: 双脚已经向前"迈"了一步（相对于初始位置）
```

#### 时刻6: phase = 270° (1500ms) ⭐重要

```
腿部运动:
  LEFT_LEG:  30*sin(270°) + 90 = -30 + 90 = 60°
  RIGHT_LEG: 30*sin(270°) + 90 = -30 + 90 = 60°
  
  → 双腿摆到最右侧，重心完全在右边

足部运动:
  LEFT_FOOT:  30*sin(270°-90°) + 5 + 90 = 30*sin(180°) + 95 = 0 + 95 = 95°
  RIGHT_FOOT: 30*sin(180°) - 5 + 90 = 0 + 85 = 85°
  
  → 双脚又回到中立位置

机器人状态:
  重心: 完全在右边
  双脚: 中立位置
  效果: 双脚又可以滑动了
```

#### 时刻7: phase = 360° (2000ms) - 周期结束

```
回到时刻1的状态，开始下一个循环
```

---

## 🎯 步态原理总结

### 核心机制：重心转移 + 双脚同步滑动

```
关键观察:
1. 左右腿同相（phase=0°）
   → 双腿一起摆动，像钟摆
   → 协同控制重心左右转移

2. 双脚同相（phase=-90°）
   → 两只脚同时向前、同时向后
   → 不是交替迈步，是同步滑动

3. 腿脚相位差90°
   → 当腿摆到极限时（90°、270°），脚处于中立
   → 当腿在中间时（0°、180°），脚处于极限
   
4. 踮脚设计（O=±5°）
   → 脚略微抬起，减少摩擦
   → 更容易滑动
```

### 行走过程（简化版）

```
步骤1 (0ms - 500ms):
  腿部: 中间 → 左摆
  脚部: 后 → 中
  重心: 向左转移
  效果: 准备滑动

步骤2 (500ms):
  腿部: 最左侧
  脚部: 中立位置
  重心: 完全在左
  效果: 双脚摩擦力最小，可以滑动！

步骤3 (500ms - 1000ms):
  腿部: 左 → 中间
  脚部: 中 → 前
  重心: 向中间回归
  效果: 双脚向前滑动

步骤4 (1000ms):
  腿部: 中间
  脚部: 最前位置
  效果: 完成半个步态，身体向前移动

步骤5 (1000ms - 1500ms):
  腿部: 中 → 右摆
  脚部: 前 → 中
  重心: 向右转移

步骤6 (1500ms):
  腿部: 最右侧
  脚部: 中立位置
  重心: 完全在右
  效果: 又一次可以滑动

步骤7 (1500ms - 2000ms):
  腿部: 右 → 中间
  脚部: 中 → 后
  效果: 准备下一个周期

完整周期: 身体向前移动了一小段距离
```

---

## 🦆 步态类型：企鹅步态

这种步态非常像企鹅走路：

```
企鹅步态特点:
  ✓ 左右摇摆身体（重心转移）
  ✓ 双脚同时滑动（不是交替）
  ✓ 依靠重心转移减轻一侧的承重
  ✓ 稳定但速度较慢
```

**为什么不用交替步态？**

```
Otto的限制:
  - 只有4个舵机控制腿和脚
  - 没有独立的"抬腿"机制
  - 无法像人类那样单腿承重、另一腿抬起
  
解决方案:
  - 用重心摆动来"减轻"一侧承重
  - 双脚同时滑动前进
  - 类似滑冰的感觉
```

---

## ⚙️ 当前优化配置

### v3优化：采样频率

```cpp
sampling_period_ = 20ms  // 50Hz更新
number_samples_ = 2000ms / 20ms = 100个采样点/周期
```

**效果**: 每个步态周期有100个中间帧，非常流畅

### v4优化：速度

```cpp
默认period = 700ms  // 原1000ms
```

**效果**: 
- 一个步态周期从2秒降低到1.4秒
- 速度提升43%

### 配合效果

```
一个步态周期（700ms）:
  采样点数: 700 / 20 = 35个点
  更新频率: 50Hz
  
结果: 快速且流畅！
```

---

## 📌 为什么±5°偏移很重要？

```cpp
O[SERVO_COUNT] = {0, 0, 5, -5, ...};
                      ^^  ^^^
                      左脚 右脚
```

**原理**:

```
没有偏移 (O=0):
  脚的角度范围: 90° ± 30° = [60°, 120°]
  60°时: 脚向后，可能完全贴地
  120°时: 脚向前，可能完全贴地
  问题: 摩擦力太大，难以滑动

有偏移 (O=±5):
  左脚范围: 95° ± 30° = [65°, 125°]
  右脚范围: 85° ± 30° = [55°, 115°]
  
  效果:
  - 脚始终略微抬起（踮脚）
  - 与地面接触面积更小
  - 摩擦力降低
  - 更容易滑动
  
  就像人类踮脚尖走路一样！
```

---

## 🔬 运动特性

### 优点

1. **稳定性高**
   - 双脚始终着地
   - 重心平稳转移
   - 不易摔倒

2. **控制简单**
   - 只用正弦波
   - 参数少
   - 易于调试

3. **对舵机要求低**
   - 不需要精确同步
   - 不需要快速响应

### 缺点

1. **速度受限**
   - 滑动步态天生较慢
   - 无法快速奔跑

2. **地面要求高**
   - 需要光滑地面
   - 摩擦力太大会卡住

3. **效率不高**
   - 能量浪费在左右摇摆上
   - 前进距离相对步态周期较短

---

## 💡 可能的改进方向

### 1. 增加步幅（振幅）

```cpp
int A[SERVO_COUNT] = {35, 35, 35, 35, 0, 0};  // 30 → 35
```

**效果**: 每步前进距离更大  
**风险**: 可能不稳定

### 2. 增加踮脚高度

```cpp
int O[SERVO_COUNT] = {0, 0, 8, -8, ...};  // ±5 → ±8
```

**效果**: 摩擦力更小，更容易滑动  
**风险**: 稳定性降低

### 3. 调整相位差（高级）

```cpp
// 让左右腿不完全同相
phase_diff[LEFT_LEG] = DEG2RAD(0);
phase_diff[RIGHT_LEG] = DEG2RAD(10);  // 略微超前
```

**效果**: 可能产生更自然的重心转移  
**风险**: 可能破坏平衡

---

## 🎓 总结

Otto的前进方式是：

1. **通过左右腿同相摆动，像钟摆一样左右转移重心**
2. **在重心偏向一侧时，双脚摩擦力减小**
3. **双脚同时向前或向后滑动（同相，-90°相位差）**
4. **重复这个过程，逐步向前移动**

这是一种**稳定但相对较慢的企鹅式步态**，适合：
- 平滑地面
- 稳定性优先
- 简单控制

当前配置（v3+v4）已经在保持稳定性的前提下，最大化了速度和流畅度！🚀

